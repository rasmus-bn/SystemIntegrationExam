{"ast":null,"code":"/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n'use strict';\n\nvar grpc = require('./grpc_extension');\n\nvar Metadata = require('./metadata');\n\nvar constants = require('./constants');\n\nvar common = require('./common');\n\nvar methodTypes = constants.methodTypes;\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\n\n\nvar InterceptorConfigurationError = function InterceptorConfigurationError(message, extra) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.extra = extra;\n};\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\n\n\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withCode = function (code) {\n  this.code = code;\n  return this;\n};\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withDetails = function (details) {\n  this.details = details;\n  return this;\n};\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withMetadata = function (metadata) {\n  this.metadata = metadata;\n  return this;\n};\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\n\n\nStatusBuilder.prototype.build = function () {\n  var status = {};\n\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n\n  if (this.details) {\n    status.details = this.details;\n  }\n\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n\n  return status;\n};\n/**\n * A builder for listener interceptors.\n * @constructor\n */\n\n\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMetadata = function (on_receive_metadata) {\n  this.metadata = on_receive_metadata;\n  return this;\n};\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMessage = function (on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveStatus = function (on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\n\n\nListenerBuilder.prototype.build = function () {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\n\n\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withStart = function (start) {\n  this.start = start;\n  return this;\n};\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withSendMessage = function (send_message) {\n  this.message = send_message;\n  return this;\n};\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withHalfClose = function (half_close) {\n  this.half_close = half_close;\n  return this;\n};\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withCancel = function (cancel) {\n  this.cancel = cancel;\n  return this;\n};\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\n\n\nRequesterBuilder.prototype.build = function () {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\n\n\nvar resolveInterceptorProviders = function (providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n\n  var interceptors = [];\n\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n\n  return interceptors;\n};\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\n\n\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n\nconst emptyNext = function () {};\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingCall.prototype._getNextCall = function (method_name) {\n  return this.next_call ? this.next_call[method_name].bind(this.next_call) : emptyNext;\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\n\n\nInterceptingCall.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1], next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\n\n\nInterceptingCall.prototype.start = function (metadata, listener) {\n  var self = this; // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n\n  var next_listener = _getInterceptingListener(listener, new EndListener()); // Build the next method in the interceptor chain\n\n\n  var next = function (metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n\n      self.next_call.start(metadata, listener);\n    }\n  };\n\n  this._callNext('start', [metadata, next_listener], next);\n};\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\n\n\nInterceptingCall.prototype.sendMessage = function (message) {\n  this._callNext('sendMessage', [message]);\n};\n/**\n * Run a close operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.halfClose = function () {\n  this._callNext('halfClose');\n};\n/**\n * Run a cancel operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.cancel = function () {\n  this._callNext('cancel');\n};\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\n\n\nInterceptingCall.prototype.cancelWithStatus = function (code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\n\n\nInterceptingCall.prototype.getPeer = function () {\n  return this._callNext('getPeer');\n};\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\n\n\nInterceptingCall.prototype.sendMessageWithContext = function (context, message) {\n  var next = this.next_call ? this.next_call.sendMessageWithContext.bind(this.next_call, context) : context;\n\n  this._callNext('sendMessage', [message], next);\n};\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\n\n\nInterceptingCall.prototype.recvMessageWithContext = function (context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\n\n\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingListener.prototype._getNextListener = function (method_name) {\n  return this.next_listener ? this.next_listener[method_name].bind(this.next_listener) : function () {};\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\n\n\nInterceptingListener.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1], next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\n\n\nInterceptingListener.prototype.onReceiveMetadata = function (metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\n\n\nInterceptingListener.prototype.onReceiveMessage = function (message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\n\n\nInterceptingListener.prototype.recvMessageWithContext = function (context, message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ? fallback.bind(this.next_listener, context) : context;\n\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\n\n\nInterceptingListener.prototype.onReceiveStatus = function (status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\n\n\nfunction EndListener() {}\n\nEndListener.prototype.onReceiveMetadata = function () {};\n\nEndListener.prototype.onReceiveMessage = function () {};\n\nEndListener.prototype.onReceiveStatus = function () {};\n\nEndListener.prototype.recvMessageWithContext = function () {};\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\n\n\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n\n  var call = channel.createCall(path, deadline, host, parent, propagate_flags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\n\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n\n      emitter._readsDone();\n\n      return;\n    }\n\n    var data = response.read;\n    var deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n\n      return;\n    }\n\n    if (data === null) {\n      emitter._readsDone();\n\n      return;\n    }\n\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\n\n\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function (op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n\n    if (batch_ops.indexOf(required_dep) === -1 && completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\n\n\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function (deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation()\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message)\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n\n    var get_listener = function () {\n      return first_listener;\n    };\n\n    final_requester.start = function (metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        first_listener.onReceiveMetadata(Metadata._fromCoreRepresentation(response.metadata));\n      };\n\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state, callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function (err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n\n    final_requester.sendMessage = function (argument) {\n      var message = serialize(argument);\n\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n\n      var callback = _getStreamReadCallback(emitter, call, get_listener, deserialize);\n\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n\n    var get_listener = function () {\n      return first_listener;\n    };\n\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function () {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function () {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\n\nfunction getLastListener(method_definition, emitter, callback) {\n  if (emitter instanceof Function) {\n    callback = emitter;\n\n    callback = function () {};\n  }\n\n  if (!(callback instanceof Function)) {\n    callback = function () {};\n  }\n\n  if (!(emitter instanceof EventEmitter && callback instanceof Function)) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\n\n\nfunction getInterceptingCall(method_definition, options, interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel, responder);\n\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\n\n\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = responder instanceof Function ? responder : function () {};\n  var emitter = responder instanceof EventEmitter ? responder : new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\n\n\nfunction _buildChain(interceptors, options) {\n  var next = function (interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\n\n\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n\n  return current_listener;\n}\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\n\n\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;","map":{"version":3,"sources":["/home/hvn15/SchoolProjects/SystemIntegrationExam/reactclient/node_modules/grpc/src/client_interceptors.js"],"names":["grpc","require","Metadata","constants","common","methodTypes","EventEmitter","InterceptorConfigurationError","message","extra","Error","captureStackTrace","constructor","name","inherits","StatusBuilder","code","details","metadata","prototype","withCode","withDetails","withMetadata","build","status","undefined","ListenerBuilder","withOnReceiveMetadata","on_receive_metadata","withOnReceiveMessage","on_receive_message","withOnReceiveStatus","on_receive_status","self","listener","onReceiveMetadata","onReceiveMessage","onReceiveStatus","RequesterBuilder","start","half_close","cancel","withStart","withSendMessage","send_message","withHalfClose","withCancel","requester","sendMessage","halfClose","resolveInterceptorProviders","providers","method_definition","Array","isArray","interceptors","i","length","provider","interceptor","push","InterceptingCall","next_call","emptyNext","_getNextCall","method_name","bind","_callNext","args","next","args_array","num_args","next_listener","_getInterceptingListener","EndListener","current_listener","cancelWithStatus","getPeer","sendMessageWithContext","context","recvMessageWithContext","InterceptingListener","delegate","_getNextListener","fallback","next_method","getCall","channel","path","options","deadline","host","parent","propagate_flags","credentials","call","Infinity","createCall","setCredentials","OP_DEPENDENCIES","opType","SEND_MESSAGE","SEND_INITIAL_METADATA","SEND_CLOSE_FROM_CLIENT","RECV_MESSAGE","_getStreamReadCallback","emitter","get_listener","deserialize","err","response","finished","_readsDone","data","read","deserialized","e","log","logVerbosity","ERROR","INTERNAL","_areBatchRequirementsMet","batch_ops","completed_ops","dependencies","flatMap","op","required_dep","indexOf","_startBatchIfReady","batch","batch_state","callback","deferred_batches","Object","keys","map","Number","startBatch","from","Set","concat","deferred_batch","deferred_batch_ops","_getUnaryInterceptor","serialize","requestSerialize","responseDeserialize","first_listener","final_requester","_getCoreRepresentation","RECV_INITIAL_METADATA","RECV_STATUS_ON_CLIENT","_fromCoreRepresentation","OK","_getClientStreamingInterceptor","wrapIgnoreNull","metadata_batch","recv_batch","chunk","encoding","isFinite","grpcWriteFlags","event","_getServerStreamingInterceptor","clone","status_batch","emit","argument","flags","send_batch","_getBidiStreamingInterceptor","_getUnaryListener","resultMessage","error","createStatusError","_getClientStreamingListener","_getServerStreamingListener","read_batch","reading","_receiveStatus","_getBidiStreamingListener","interceptorGenerators","UNARY","CLIENT_STREAMING","SERVER_STREAMING","BIDI_STREAMING","listenerGenerators","getLastListener","Function","method_type","getMethodType","generator","getInterceptingCall","responder","last_interceptor","_getLastInterceptor","all_interceptors","_buildChain","head_interceptor","rest_interceptors","slice","chain","_isInterceptingListener","exports"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n\n'use strict';\n\nvar grpc = require('./grpc_extension');\nvar Metadata = require('./metadata');\nvar constants = require('./constants');\nvar common = require('./common');\nvar methodTypes = constants.methodTypes;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\nvar InterceptorConfigurationError =\n  function InterceptorConfigurationError(message, extra) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.extra = extra;\n  };\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withCode = function(code) {\n  this.code = code;\n  return this;\n};\n\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withDetails = function(details) {\n  this.details = details;\n  return this;\n};\n\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withMetadata = function(metadata) {\n  this.metadata = metadata;\n  return this;\n};\n\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\nStatusBuilder.prototype.build = function() {\n  var status = {};\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n  if (this.details) {\n    status.details = this.details;\n  }\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n  return status;\n};\n\n/**\n * A builder for listener interceptors.\n * @constructor\n */\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMetadata =\n  function(on_receive_metadata) {\n    this.metadata = on_receive_metadata;\n    return this;\n  };\n\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMessage = function(on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveStatus = function(on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\nListenerBuilder.prototype.build = function() {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withStart = function(start) {\n  this.start = start;\n  return this;\n};\n\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withSendMessage = function(send_message) {\n  this.message = send_message;\n  return this;\n};\n\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withHalfClose = function(half_close) {\n  this.half_close = half_close;\n  return this;\n};\n\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withCancel = function(cancel) {\n  this.cancel = cancel;\n  return this;\n};\n\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\nRequesterBuilder.prototype.build = function() {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\nvar resolveInterceptorProviders = function(providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n  var interceptors = [];\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n  return interceptors;\n};\n\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n\nconst emptyNext = function() {};\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingCall.prototype._getNextCall = function(method_name) {\n  return this.next_call ?\n    this.next_call[method_name].bind(this.next_call) :\n    emptyNext;\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\nInterceptingCall.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1],\n                                           next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\nInterceptingCall.prototype.start = function(metadata, listener) {\n  var self = this;\n\n  // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n  var next_listener = _getInterceptingListener(listener, new EndListener());\n\n  // Build the next method in the interceptor chain\n  var next = function(metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n      self.next_call.start(metadata, listener);\n    }\n  };\n  this._callNext('start', [metadata, next_listener], next);\n};\n\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\nInterceptingCall.prototype.sendMessage = function(message) {\n  this._callNext('sendMessage', [message]);\n};\n\n/**\n * Run a close operation through the interceptor chain\n */\nInterceptingCall.prototype.halfClose = function() {\n  this._callNext('halfClose');\n};\n\n/**\n * Run a cancel operation through the interceptor chain\n */\nInterceptingCall.prototype.cancel = function() {\n  this._callNext('cancel');\n};\n\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\nInterceptingCall.prototype.cancelWithStatus = function(code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\nInterceptingCall.prototype.getPeer = function() {\n  return this._callNext('getPeer');\n};\n\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\nInterceptingCall.prototype.sendMessageWithContext = function(context, message) {\n  var next = this.next_call ?\n    this.next_call.sendMessageWithContext.bind(this.next_call, context) :\n    context;\n  this._callNext('sendMessage', [message], next);\n};\n\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\nInterceptingCall.prototype.recvMessageWithContext = function(context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingListener.prototype._getNextListener = function(method_name) {\n  return this.next_listener ?\n    this.next_listener[method_name].bind(this.next_listener) :\n    function(){};\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\nInterceptingListener.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1],\n                                          next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\nInterceptingListener.prototype.onReceiveMetadata = function(metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\nInterceptingListener.prototype.onReceiveMessage = function(message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\nInterceptingListener.prototype.recvMessageWithContext = function(context,\n                                                                 message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ?\n    fallback.bind(this.next_listener, context) :\n    context;\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\nInterceptingListener.prototype.onReceiveStatus = function(status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\nfunction EndListener() {}\nEndListener.prototype.onReceiveMetadata = function(){};\nEndListener.prototype.onReceiveMessage = function(){};\nEndListener.prototype.onReceiveStatus = function(){};\nEndListener.prototype.recvMessageWithContext = function(){};\n\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host,\n                                parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n      emitter._readsDone();\n      return;\n    }\n    var data = response.read;\n    var deserialized;\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n      return;\n    }\n    if (data === null) {\n      emitter._readsDone();\n      return;\n    }\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function(op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 &&\n        completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function(deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]:\n          metadata._getCoreRepresentation(),\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                       function() {});\n    };\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message),\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                         function() {});\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        response.metadata =\n          Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter,\n  callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function () { };\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    final_requester.start = function(metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        first_listener.onReceiveMetadata(\n          Metadata._fromCoreRepresentation(response.metadata));\n      };\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state,\n                                       callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function(err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n    final_requester.sendMessage = function(argument) {\n      var message = serialize(argument);\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n    final_requester.halfClose = function() {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function() {});\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      var callback = _getStreamReadCallback(emitter, call,\n        get_listener, deserialize);\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function() {};\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call,\n        get_listener, deserialize));\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\n\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\nfunction getLastListener(method_definition, emitter, callback) {\n  if (emitter instanceof Function) {\n    callback = emitter;\n    callback = function() {};\n  }\n  if (!(callback instanceof Function)) {\n    callback = function() {};\n  }\n  if (!((emitter instanceof EventEmitter) &&\n       (callback instanceof Function))) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\nfunction getInterceptingCall(method_definition, options,\n                             interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel,\n                                            responder);\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = (responder instanceof Function) ? responder : function() {};\n  var emitter = (responder instanceof EventEmitter) ? responder :\n                                                      new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\nfunction _buildChain(interceptors, options) {\n  var next = function(interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n  return current_listener;\n}\n\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\n\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;\n"]},"metadata":{},"sourceType":"script"}